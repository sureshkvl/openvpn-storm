// Generated by CoffeeScript 1.4.0
(function() {
  var StormData, VpnServerData, VpnUserData, openvpn,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  StormData = require('stormagent').StormData;

  VpnServerData = (function(_super) {
    var serverSchema;

    __extends(VpnServerData, _super);

    serverSchema = {
      name: "openvpn",
      type: "object",
      additionalProperties: false,
      properties: {
        port: {
          "type": "number",
          "required": true
        },
        dev: {
          "type": "string",
          "required": true
        },
        proto: {
          "type": "string",
          "required": true
        },
        ca: {
          "type": "string",
          "required": true
        },
        dh: {
          "type": "string",
          "required": true
        },
        cert: {
          "type": "string",
          "required": true
        },
        key: {
          "type": "string",
          "required": true
        },
        server: {
          "type": "string",
          "required": true
        },
        'ifconfig-pool-persist': {
          "type": "string",
          "required": false
        },
        'script-security': {
          "type": "string",
          "required": false
        },
        multihome: {
          "type": "boolean",
          "required": false
        },
        management: {
          "type": "string",
          "required": false
        },
        cipher: {
          "type": "string",
          "required": false
        },
        'tls-cipher': {
          "type": "string",
          "required": false
        },
        auth: {
          "type": "string",
          "required": false
        },
        topology: {
          "type": "string",
          "required": false
        },
        'route-gateway': {
          "type": "string",
          "required": false
        },
        'client-config-dir': {
          "type": "string",
          "required": false
        },
        'ccd-exclusive': {
          "type": "boolean",
          "required": false
        },
        'client-to-client': {
          "type": "boolean",
          "required": false
        },
        route: {
          items: {
            type: "string"
          }
        },
        push: {
          items: {
            type: "string"
          }
        },
        'tls-timeout': {
          "type": "number",
          "required": false
        },
        'max-clients': {
          "type": "number",
          "required": false
        },
        'persist-key': {
          "type": "boolean",
          "required": false
        },
        'persist-tun': {
          "type": "boolean",
          "required": false
        },
        status: {
          "type": "string",
          "required": false
        },
        keepalive: {
          "type": "string",
          "required": false
        },
        'comp-lzo': {
          "type": "string",
          "required": false
        },
        sndbuf: {
          "type": "number",
          "required": false
        },
        rcvbuf: {
          "type": "number",
          "required": false
        },
        txqueuelen: {
          "type": "number",
          "required": false
        },
        'replay-window': {
          "type": "string",
          "required": false
        },
        'duplicate-cn': {
          "type": "boolean",
          "required": false
        },
        'log-append': {
          "type": "string",
          "required": false
        },
        verb: {
          "type": "number",
          "required": false
        },
        mlock: {
          "type": "boolean",
          "required": false
        }
      }
    };

    function VpnServerData(id, data) {
      VpnServerData.__super__.constructor.call(this, id, data, serverSchema);
    }

    return VpnServerData;

  })(StormData);

  VpnUserData = (function(_super) {
    var userSchema;

    __extends(VpnUserData, _super);

    userSchema = {
      name: "openvpn",
      type: "object",
      additionalProperties: false,
      properties: {
        id: {
          type: "string",
          required: true
        },
        email: {
          type: "string",
          required: false
        },
        cname: {
          type: "string",
          required: false
        },
        push: {
          items: {
            type: "string"
          }
        }
      }
    };

    function VpnUserData(id, data) {
      VpnUserData.__super__.constructor.call(this, id, data, userSchema);
    }

    return VpnUserData;

  })(StormData);

  openvpn = (function() {
    var db, exec, fs, uuid, validate;

    fs = require('fs');

    validate = require('json-schema').validate;

    exec = require('child_process').exec;

    uuid = require('node-uuid');

    openvpn.db = db = {
      server: require('dirty')('/tmp/openvpnservers.db'),
      client: require('dirty')('/tmp/openvpnclients.db'),
      user: require('dirty')('/tmp/openvpnusers.db')
    };

    function openvpn(config) {
      console.log('openvpn initialized');
      this.clientdb = db.client;
      this.serverdb = db.server;
      this.serverdb.on('load', function() {
        console.log('loaded openvpnserver.db');
        return this.forEach(function(key, val) {
          return console.log('found ' + key);
        });
      });
      this.clientdb.on('load', function() {
        console.log('loaded openvpnclient.db');
        return this.forEach(function(key, val) {
          return console.log('found ' + key);
        });
      });
      console.log('dbs ' + this.clientdb + this.serverdb);
    }

    openvpn.prototype.getCcdPath = function(entry) {
      console.log(entry.config);
      return entry.config["client-config-dir"];
    };

    openvpn.prototype.getServerEntryByID = function(id) {
      var entry;
      entry = this.serverdb.get(id);
      if (entry) {
        return entry;
      } else {
        return new Error("Invalid ID posting! " + id);
      }
    };

    openvpn.prototype.getMgmtPort = function(entry) {
      var port;
      console.log('entry is ' + entry.config);
      console.log('management ip port is ' + entry.config.management);
      port = entry.config.management.split(" ");
      return port[1];
    };

    openvpn.prototype.getStatusFile = function(entry) {
      console.log('status file is ' + entry.status);
      return entry.config.status;
    };

    openvpn.prototype["new"] = function(config) {
      var instance;
      instance = {};
      instance.id = uuid.v4();
      instance.config = config;
      return instance;
    };

    openvpn.prototype.configvpn = function(instance, filename, idb, callback) {
      var config, i, key, service, val, _i, _len, _ref;
      console.log('idb is ' + idb);
      service = "openvpn";
      config = '';
      _ref = instance.config;
      for (key in _ref) {
        val = _ref[key];
        switch (typeof val) {
          case "object":
            if (val instanceof Array) {
              for (_i = 0, _len = val.length; _i < _len; _i++) {
                i = val[_i];
                if (key === "route") {
                  config += "" + key + " " + i + "\n";
                }
                if (key === "push") {
                  config += "" + key + " \"" + i + "\"\n";
                }
              }
            }
            break;
          case "number":
          case "string":
            config += key + ' ' + val + "\n";
            break;
          case "boolean":
            config += key + "\n";
        }
      }
      console.log('writing vpn config onto file' + filename);
      fs.writeFileSync(filename, config);
      exec("touch /config/" + service + "/on");
      try {
        idb.set(instance.id, instance, function() {
          return console.log("" + instance.id + " added to OpenVPN service configuration");
        });
        return callback({
          result: true
        });
      } catch (err) {
        console.log(err);
        return callback(err);
      }
    };

    openvpn.prototype.addUser = function(body, filename, callback) {
      var config, i, id, key, service, val, _i, _len;
      service = "openvpn";
      config = '';
      for (key in body) {
        val = body[key];
        switch (typeof val) {
          case "object":
            if (val instanceof Array) {
              for (_i = 0, _len = val.length; _i < _len; _i++) {
                i = val[_i];
                if (key === "iroute") {
                  config += "" + key + " " + i + "\n";
                }
                if (key === "push") {
                  config += "" + key + " \"" + i + "\"\n";
                }
              }
            }
        }
      }
      id = body.id;
      fs.writeFileSync(filename, config);
      try {
        'TODO: implement a module to act on service';

        console.log("exec : monit restart " + service);
        db.user.set(id, body, function() {
          console.log("" + id + " added to OpenVPN service configuration");
          return console.log(body);
        });
        return callback({
          result: true
        });
      } catch (err) {
        return callback(err);
      }
    };

    openvpn.prototype.delInstance = function(id, idb, filename, callback) {
      var entry,
        _this = this;
      entry = idb.get(id);
      console.log('filename to be removed ' + filename);
      return fs.unlink(filename, function(err) {
        var error;
        console.log('result of removing file ' + err);
        if (!(err instanceof Error)) {
          idb.rm(id, function() {
            return console.log("removed VPN client ID: " + id);
          });
          return callback(true);
        } else {
          if (err instanceof Error) {
            error = new Error("Unable to delete the instance " + id + "! " + err);
          }
          return callback(error);
        }
      });
    };

    openvpn.prototype.delUser = function(userid, ccdpath, callback) {
      var entry, err, exists, file, filename, path;
      path = require('path');
      entry = db.user.get(userid);
      try {
        if (!entry) {
          throw new Error("user does not exist!");
        }
        if (entry.email) {
          file = entry.email;
        } else {
          file = entry.cname;
        }
        filename = ("" + ccdpath) + ("/" + file);
        console.log("removing user config on " + filename + "...");
        exists = path.existsSync(filename);
        if (!exists) {
          console.log('file removed already');
          err = new Error("user is already removed!");
          return callback(err);
        } else {
          console.log('remove the file');
          return fs.unlink(filename, function(err) {
            if (err) {
              callback(err);
            } else {
              console.log('removed file');
            }
            db.user.rm(userid, function() {
              return console.log("removed VPN user ID: " + userid);
            });
            return callback(true);
          });
        }
      } catch (err) {
        return callback(err);
      }
    };

    openvpn.prototype.listServers = function() {
      var res;
      res = {
        "servers": []
      };
      this.serverdb.forEach(function(key, val) {
        console.log('found server ' + key);
        return res.servers.push(val);
      });
      console.log('listing');
      return res.servers;
    };

    openvpn.prototype.listClientByID = function(key) {
      var entry;
      entry = this.clientdb.get(key);
      if (!entry) {
        return new Error("Entry with the given key " + key + " does not exist");
      }
      return entry;
    };

    openvpn.prototype.listClients = function() {
      var res;
      res = {
        "clients": []
      };
      this.clientdb.forEach(function(key, val) {
        console.log('found client ' + key);
        if (key !== "management") {
          return res.clients.push(val);
        }
      });
      console.log('listing');
      return res.clients;
    };

    openvpn.prototype.getInfo = function(port, filename, id, callback) {
      var Lazy, conn, net, res, status,
        _this = this;
      console.log('in getInfo');
      res = {
        id: id,
        users: [],
        connections: []
      };
      db.user.forEach(function(key, val) {
        console.log('found ' + key);
        return res.users.push(val);
      });
      Lazy = require('lazy');
      status = new Lazy;
      status.lines.map(String).filter(function(line) {
        return !(/^OpenVPN/.test(line) || /^Updated/.test(line) || /^Common/.test(line) || /^ROUTING/.test(line) || /^Virtual/.test(line) || /^GLOBAL/.test(line) || /^UNDEF/.test(line) || /^END/.test(line) || /^Max bcast/.test(line));
      }).map(function(line) {
        return line.trim().split(',');
      }).forEach(function(fields) {
        var conn, _i, _len, _ref, _results;
        switch (fields.length) {
          case 5:
            return res.connections.push({
              cname: fields[0],
              remote: fields[1],
              received: fields[2],
              sent: fields[3],
              since: fields[4]
            });
          case 4:
            _ref = res.connections;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              conn = _ref[_i];
              if (conn.cname === fields[1]) {
                _results.push(conn.ip = fields[0]);
              } else {
                _results.push(void 0);
              }
            }
            return _results;
        }
      }).join(function() {
        console.log(res);
        return callback(res);
      });
      console.log("checking for live connections...");
      net = require('net');
      conn = net.connect(port, '127.0.0.1', function() {
        var response,
          _this = this;
        console.log('connection to openvpn mgmt successful!');
        response = '';
        this.setEncoding('ascii');
        this.on('prompt', function() {
          return _this.write("status\n");
        });
        this.on('response', function() {
          console.log("response: " + response);
          status.emit('end');
          _this.write("exit\n");
          return _this.end;
        });
        this.on('data', function(data) {
          console.log("read: " + data + "\n");
          if (/^>/.test(data)) {
            return _this.emit('prompt');
          } else {
            response += data;
            status.emit('data', data);
            if (/^END$/gm.test(response)) {
              return _this.emit('response');
            }
          }
        });
        return this.on('end', function() {
          console.log('connection to openvpn mgmt ended!');
          status.emit('end');
          return _this.end;
        });
      });
      return conn.on('error', function(error) {
        var statusfile, stream;
        console.log(error);
        statusfile = filename;
        console.log("failling back to processing " + statusfile + "...");
        fs = require('fs');
        stream = fs.createReadStream(statusfile, {
          encoding: 'utf8'
        });
        stream.on('open', function() {
          console.log("sending " + statusfile + " to lazy status...");
          stream.on('data', function(data) {
            return status.emit('data', data);
          });
          return stream.on('end', function() {
            return status.emit('end');
          });
        });
        return stream.on('error', function(error) {
          console.log(error);
          return status.emit('end');
        });
      });
    };

    return openvpn;

  })();

  module.exports = openvpn;

  module.exports.VpnServerData = VpnServerData;

  module.exports.VpnUserData = VpnUserData;

}).call(this);
