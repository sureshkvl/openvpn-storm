// Generated by CoffeeScript 1.8.0
(function() {
  var DeleteClient, DeleteServer, DeleteUser, PostClient, PostServer, PostUser, Promise, PutClient, PutServer, Start, Stop, Update, UpdateClient, UpdateServer, UserExists, Validate, assert, async, diff, getPromise, needle, schema, schema_client, schema_server, schema_user, utils, validate;

  validate = require('json-schema').validate;

  assert = require('assert');

  Promise = require('bluebird');

  async = require('async');

  needle = Promise.promisifyAll(require('needle'));

  utils = require('utils')._;

  diff = require('deep-diff').diff;

  schema_user = require('./schema').user;

  schema_server = require('./schema').server;

  schema_client = require('./schema').client;

  schema = {
    "server": schema_server,
    "client": schema_client,
    "user": schema_user
  };

  getPromise = function() {
    return new Promise(function(resolve, reject) {
      return resolve();
    });
  };

  PostServer = function(baseUrl, server) {
    return needle.postAsync(baseUrl + "/openvpn/server", server.config, {
      json: true
    }).then((function(_this) {
      return function(resp) {
        if (resp[0].statusCode !== 200) {
          throw new Error('invalidStatusCode');
        }
        server.instance = resp[1].id;
        if (server.history == null) {
          server.history = {};
        }
        server.history.config = utils.extend({}, server.config);
        server.history.users = [];
        return server;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  PostClient = function(baseUrl, client) {
    return needle.postAsync(baseUrl + "/openvpn/client", client.config, {
      json: true
    }).then((function(_this) {
      return function(resp) {
        if (resp[0].statusCode !== 200) {
          throw new Error('invalidStatusCode');
        }
        client.instance = resp[1].id;
        if (client.history == null) {
          client.history = {};
        }
        client.history.config = utils.extend({}, client.config);
        return client;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  DeleteServer = function(baseUrl, server) {
    return needle.deleteAsync(baseUrl + ("/openvpn/server/" + server.instance), {
      json: true
    }).then((function(_this) {
      return function(resp) {
        if (resp[0].statusCode !== 204) {
          throw new Error('invalidStatusCode');
        }
        return server;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  DeleteClient = function(baseUrl, client) {
    return needle.deleteAsync(baseUrl + ("/openvpn/client/" + client.instance), {
      json: true
    }).then((function(_this) {
      return function(resp) {
        if (resp[0].statusCode !== 204) {
          throw new Error('invalidStatusCode');
        }
        return client;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  PutServer = function(baseUrl, server) {
    return needle.putAsync(baseUrl + ("/openvpn/server/" + server.instance), server.config, {
      json: true
    }).then((function(_this) {
      return function(resp) {
        if (resp[0].statusCode !== 200) {
          throw new Error('invalidStatusCode');
        }
        server.history.config = utils.extend({}, server.config);
        return server;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  PutClient = function(baseUrl, client) {
    return needle.putAsync(baseUrl + ("/openvpn/client/" + client.instance), client.config, {
      json: true
    }).then((function(_this) {
      return function(resp) {
        console.log("respo code", resp[0].statusCode);
        if (resp[0].statusCode !== 200) {
          throw new Error('invalidStatusCode');
        }
        client.history.config = utils.extend({}, client.config);
        return client;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  PostUser = function(baseUrl, serverid, user) {
    return needle.postAsync(baseUrl + ("/openvpn/server/" + serverid + "/users"), user, {
      json: true
    }).then((function(_this) {
      return function(resp) {
        if (resp[0].statusCode !== 200) {
          throw new Error('invalidStatusCode');
        }
        return resp.body;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  DeleteUser = function(baseUrl, serverid, user) {
    return needle.deleteAsync(baseUrl + ("/openvpn/server/" + serverid + "/users/" + user.cname), {
      json: true
    }).then((function(_this) {
      return function(resp) {
        console.log("response code is", resp[0].statusCode);
        if (resp[0].statusCode !== 200) {
          throw new Error('invalidStatusCode');
        }
        return resp.body;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  Start = function(context) {
    var clients, config, configObj, servers, _ref, _ref1, _ref2;
    if (!(context.bInstalledPackages && context.service.name)) {
      throw new Error('openvpn-storm.Start missingParams');
    }
    configObj = (_ref = context.service.factoryConfig) != null ? _ref.config : void 0;
    config = configObj[context.service.name];
    servers = (_ref1 = config.servers) != null ? _ref1 : [];
    clients = (_ref2 = config.clients) != null ? _ref2 : [];
    if (utils.isEmpty(servers) && utils.isEmpty(clients)) {
      return context;
    }
    if (config.enable !== true) {
      return context;
    }
    return getPromise().then((function(_this) {
      return function(resp) {
        return Promise.map(servers, function(server) {
          return PostServer(context.baseUrl, server);
        }).then(function(resp) {
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return Promise.map(clients, function(client) {
          return PostClient(context.baseUrl, client);
        }).then(function(resp) {
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return context;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  Stop = function(context) {
    var clients, config, servers, _ref, _ref1;
    if (!(context.bInstalledPackages && context.service.name)) {
      throw new Error('openvpn-storm.Stop missingParams');
    }
    config = context.policyConfig[context.service.name];
    servers = (_ref = config.servers) != null ? _ref : [];
    clients = (_ref1 = config.clients) != null ? _ref1 : [];
    if (utils.isEmpty(servers) && utils.isEmpty(clients)) {
      throw new Error("openvpn-storm.Stop missing server,client info");
    }
    if (config.enable !== true) {
      return context;
    }
    return getPromise().then((function(_this) {
      return function(resp) {
        return Promise.map(servers, function(server) {
          return DeleteServer(context.baseUrl, server);
        }).then(function(resp) {
          servers = utils.difference(servers, resp);
          config.servers = servers;
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return Promise.map(clients, function(client) {
          return DeleteClient(context.baseUrl, client);
        }).then(function(resp) {
          clients = utils.difference(clients, resp);
          config.clients = clients;
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return context;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  UserExists = function(list, id) {
    var item, _i, _len;
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      item = list[_i];
      if (item.id === id) {
        return true;
      }
    }
    return false;
  };


  /*
   *Update logic
      iterate the clients array
         a. if instance is not present - assume that is the new client . 
             - post the client and update the instance id, and save the config in the history
         b. if the instance is present (assume this is the existing running client)
              i) diff with config and history config 
                  if diff is found, then client config is changed,
                  put the client config 
      
      iterate the servers array. 
         a. if instance is not preset  - assume this is  a new server.  
             - post the server and update the instance id, and save the config in history
         b.if instance is present, (assume this is the existing running server) 
              i) diff with config and history config 
                  if diff is found, then server config is changed,
                  put the server config 
  
         c. check the current users aray and history users array in the server         
               if current user is not present in the history users 
                        then this is the new user , POST the new user and update it in the history users
              if history user is not present in the current users , 
                         then this uses to be deleted. DELETE this user
   */

  UpdateClient = function(baseUrl, client) {
    return getPromise().then((function(_this) {
      return function(resp) {
        var differences;
        if (client.instance == null) {
          return PostClient(baseUrl, client);
        }
        differences = diff(client.config, client.history.config);
        if (!(utils.isEmpty(differences) || (differences == null))) {
          return PutClient(baseUrl, client);
        }
        return client;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  UpdateServer = function(baseUrl, server) {
    return getPromise().then((function(_this) {
      return function(resp) {
        var differences;
        if (server.instance == null) {
          return PostServer(baseUrl, server);
        }
        differences = diff(server.config, server.history.config);
        if (!(utils.isEmpty(differences) || (differences == null))) {
          return PutServer(baseUrl, server);
        }
      };
    })(this)).then((function(_this) {
      return function(resp) {
        var currentusers, historyusers, _ref, _ref1;
        currentusers = (_ref = server.users) != null ? _ref : [];
        historyusers = (_ref1 = server.history.users) != null ? _ref1 : [];
        console.log("currentusers ", currentusers);
        return Promise.map(currentusers, function(currentuser) {
          var result;
          console.log("currentuser  ", currentuser);
          result = UserExists(historyusers, currentuser.id);
          if (result === false) {
            historyusers.push(currentuser);
            return PostUser(baseUrl, server.instance, currentuser);
          }
        }).then(function(resp) {
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(resp) {
        var currentusers, historyusers, _ref, _ref1;
        currentusers = (_ref = server.users) != null ? _ref : [];
        historyusers = (_ref1 = server.history.users) != null ? _ref1 : [];
        console.log("historyusers ", historyusers);
        return Promise.map(historyusers, function(historyuser) {
          var result;
          console.log("historyuser ", historyuser);
          result = UserExists(currentusers, historyuser.id);
          if (result === false) {
            historyusers.pop(historyuser);
            return DeleteUser(baseUrl, server.instance, historyuser);
          }
        }).then(function(resp) {
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return resp;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  Update = function(context) {
    var clients, config, servers, _ref, _ref1;
    if (!(context.bInstalledPackages && context.service.name)) {
      throw new Error('openvpn-storm.Update missingParams');
    }
    config = context.policyConfig[context.service.name];
    servers = (_ref = config.servers) != null ? _ref : [];
    clients = (_ref1 = config.clients) != null ? _ref1 : [];
    return getPromise().then((function(_this) {
      return function(resp) {
        return Promise.map(clients, function(client) {
          return UpdateClient(context.baseUrl, client);
        }).then(function(resp) {
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return Promise.map(servers, function(server) {
          return UpdateServer(context.baseUrl, server);
        }).then(function(resp) {
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(response) {
        return context;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  Validate = function(config) {
    var chk, client, server, user, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (!((config.servers != null) && (config.clients != null))) {
      throw new Error("openvpn.Validate - invalid input");
    }
    _ref = config.servers;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      server = _ref[_i];
      chk = validate(server.config, schema['server']);
      console.log('server validate result ', chk);
      if (!chk.valid) {
        throw new Error("server schema check failed" + chk.valid);
        return false;
      }
      if (server.users != null) {
        _ref1 = server.users;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          user = _ref1[_j];
          chk = validate(user, schema['user']);
          console.log('user validate result ', chk);
          if (!chk.valid) {
            throw new Error("user schema check failed" + chk.valid);
            return false;
          }
        }
      }
    }
    _ref2 = config.clients;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      client = _ref2[_k];
      chk = validate(client.config, schema['client']);
      console.log('client validate result ', chk);
      if (!chk.valid) {
        throw new Error("client schema check failed" + chk.valid);
        return false;
      }
    }
    return true;
  };


  /*
      policyConfig = {}
      if config.enable and config.coreConfig
          policyConfig.zebra = config.coreConfig
      if config.protocol.ospf.enable and config.protocol.ospf.config
          policyConfig.ospfd = config.protocol.ospf.config
  
      for name, conf of policyConfig
          options = {}
          options.propertyName = name
          res = Validator.validate conf, schema[name], options
          if res.errors?.length
              throw new Error "openvpn.Validate ", res
   */

  module.exports.start = Start;

  module.exports.stop = Stop;

  module.exports.update = Update;

  module.exports.validate = Validate;

}).call(this);
