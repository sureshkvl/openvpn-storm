// Generated by CoffeeScript 1.9.3
(function() {
  var Promise, Start, Stop, Update, UserExists, Valid, Validator, assert, async, diff, getPromise, needle, schema, schema_client, schema_server, schema_user, utils;

  Valid = require('jsonschema').Validator;

  Validator = new Valid;

  assert = require('assert');

  Promise = require('bluebird');

  async = require('async');

  needle = Promise.promisifyAll(require('needle'));

  utils = require('utils')._;

  diff = require('deep-diff').diff;

  schema_user = require('./schema').user;

  schema_server = require('./schema').server;

  schema_client = require('./schema').client;

  schema = {
    "server": schema_server,
    "client": schema_client,
    "user": schema_server
  };

  getPromise = function() {
    return new Promise(function(resolve, reject) {
      return resolve();
    });
  };

  Start = function(context) {
    var clients, servers;
    if (!(context.bInstalledPackages && context.service.name)) {
      throw new Error('openvpn-storm.Start missingParams');
    }
    if (utils.isEmpty(context.service.servers) && utils.isEmpty(context.service.clients)) {
      throw new Error("openvpn-storm.Start missing server,client info");
    }
    if (!utils.isEmpty(context.service.servers)) {
      servers = context.service.servers;
    }
    if (!utils.isEmpty(context.service.clients)) {
      clients = context.service.clients;
    }
    return getPromise().then((function(_this) {
      return function(resp) {
        if (servers != null) {
          return Promise.map(servers, function(server) {
            return needle.postAsync(context.baseUrl + "/openvpn/server", server.config, {
              json: true
            }).then((function(_this) {
              return function(resp) {
                if (resp[0].statusCode !== 200) {
                  throw new Error('invalidStatusCode');
                }
                server.instance = resp[1].id;
                if (server.history == null) {
                  server.history = {};
                }
                server.history.config = utils.extend({}, server.config);
                server.history.users = [];
                return server;
              };
            })(this))["catch"]((function(_this) {
              return function(err) {
                throw err;
              };
            })(this));
          }).then(function(resp) {
            return resp;
          })["catch"](function(err) {
            throw err;
          });
        }
      };
    })(this)).then((function(_this) {
      return function(resp) {
        if (clients != null) {
          return Promise.map(clients, function(client) {
            return needle.postAsync(context.baseUrl + "/openvpn/client", client.config, {
              json: true
            }).then((function(_this) {
              return function(resp) {
                if (resp[0].statusCode !== 200) {
                  throw new Error('invalidStatusCode');
                }
                client.instance = resp[1].id;
                if (client.history == null) {
                  client.history = {};
                }
                client.history.config = utils.extend({}, client.config);
                return client;
              };
            })(this))["catch"]((function(_this) {
              return function(err) {
                throw err;
              };
            })(this));
          }).then(function(resp) {
            return resp;
          })["catch"](function(err) {
            throw err;
          });
        }
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return context;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  Stop = function(context) {
    var clients, servers;
    if (utils.isEmpty(context.service.servers) && utils.isEmpty(context.service.clients)) {
      throw new Error("openvpn-storm.Start missing server,client info");
    }
    if (!utils.isEmpty(context.service.servers)) {
      servers = context.service.servers;
    }
    if (!utils.isEmpty(context.service.clients)) {
      clients = context.service.clients;
    }
    return getPromise().then((function(_this) {
      return function(resp) {
        if (servers != null) {
          return Promise.map(servers, function(server) {
            return needle.deleteAsync(context.baseUrl + ("/openvpn/server/" + server.instance), {
              json: true
            }).then((function(_this) {
              return function(resp) {
                if (resp[0].statusCode !== 204) {
                  throw new Error('invalidStatusCode');
                }
                return "done";
              };
            })(this))["catch"]((function(_this) {
              return function(err) {
                throw err;
              };
            })(this));
          }).then(function(resp) {
            return resp;
          })["catch"](function(err) {
            throw err;
          });
        }
      };
    })(this)).then((function(_this) {
      return function(resp) {
        if (clients != null) {
          return Promise.map(clients, function(client) {
            return needle.deleteAsync(context.baseUrl + ("/openvpn/client/" + client.instance), {
              json: true
            }).then((function(_this) {
              return function(resp) {
                if (resp[0].statusCode !== 204) {
                  throw new Error('invalidStatusCode');
                }
                return "done";
              };
            })(this))["catch"]((function(_this) {
              return function(err) {
                throw err;
              };
            })(this));
          }).then(function(resp) {
            return resp;
          })["catch"](function(err) {
            throw err;
          });
        }
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return context;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  UserExists = function(list, id) {
    var i, item, len;
    for (i = 0, len = list.length; i < len; i++) {
      item = list[i];
      if (item.id === id) {
        return true;
      }
    }
    return false;
  };

  Update = function(context) {
    var clients, servers;
    if (!(context.bInstalledPackages && context.service.name)) {
      throw new Error('openvpn-storm.Start missingParams');
    }
    if (utils.isEmpty(context.service.servers) && utils.isEmpty(context.service.clients)) {
      throw new Error("openvpn-storm.Start missing server,client info");
    }

    /*
    #logic
    step1. iterate the servers array. 
       a. if instance is not preset  - assume this is  a new server.  
           - post the server and update the instance id, and save the config in history
       b.if instance is present, (assume this is the existing running server) 
            i) diff with config and history config 
                if diff is found, then server config is changed,
                put the server config 
    
            ii) check the current users aray and history users array              
                - if current user is not present in the history users 
                      then this is the new user , POST the new user and update it in the history users
                - if history user is not present in the current users , 
                       then this uses to be deleted. DELETE this user
    step2: iterate the clients array
       a. if instance is not present - assume that is the new client . 
           - post the client and update the instance id, and save the config in the history
       b. if the instance is present (assume this is the existing running client)
            i) diff with config and history config 
                if diff is found, then client config is changed,
                put the client config
     */
    if (!utils.isEmpty(context.service.servers)) {
      servers = context.service.servers;
    }
    if (!utils.isEmpty(context.service.clients)) {
      clients = context.service.clients;
    }
    return getPromise().then((function(_this) {
      return function(resp) {
        if (servers != null) {
          Promise.map(servers, function(server) {
            var currentusers, differences, historyusers, i, j, len, len1, result, results, user;
            console.log("inside update server map ", server);
            if (server.instance == null) {
              console.log("server instance not present .. hence new server case");
              return needle.postAsync(context.baseUrl + "/openvpn/server", server.config, {
                json: true
              }).then(function(resp) {
                if (resp[0].statusCode !== 200) {
                  throw new Error('invalidStatusCode');
                }
                server.instance = resp[1].id;
                if (server.history == null) {
                  server.history = {};
                }
                server.history.config = utils.extend({}, server.config);
                server.history.users = [];
                return server;
              })["catch"](function(err) {
                throw err;
              });
            } else if ((server.instance != null) && (server.config != null) && (server.history.config != null)) {
              console.log("server instance is present .. hence server modification case");
              differences = diff(server.config, server.history.config);
              console.log(differences);
              if (!(utils.isEmpty(differences) || (differences == null))) {
                console.log("server config difference is found...server put call");
                needle.putAsync(context.baseUrl + ("/openvpn/server/" + server.instance), server.config, {
                  json: true
                }).then(function(resp) {
                  if (resp[0].statusCode !== 200) {
                    throw new Error('invalidStatusCode');
                  }
                  server.history.config = server.config;
                  return server;
                })["catch"](function(err) {
                  throw err;
                });
              }
              currentusers = server.users;
              historyusers = server.history.users;
              for (i = 0, len = currentusers.length; i < len; i++) {
                user = currentusers[i];
                if (!(!utils.isEmpty(currentusers))) {
                  continue;
                }
                result = UserExists(historyusers, user.id);
                if (result === false) {
                  console.log("this user is a new user- To be posted", user);
                  needle.postAsync(context.baseUrl + ("/openvpn/server/" + server.instance + "/users"), user, {
                    json: true
                  }).then(function(resp) {
                    if (resp[0].statusCode !== 200) {
                      throw new Error('invalidStatusCode');
                    }
                    historyusers.push(user);
                    return resp.body;
                  })["catch"](function(err) {
                    throw err;
                  });
                }
              }
              results = [];
              for (j = 0, len1 = historyusers.length; j < len1; j++) {
                user = historyusers[j];
                if (!(!utils.isEmpty(historyusers))) {
                  continue;
                }
                result = UserExists(currentusers, user.id);
                if (result === false) {
                  console.log("this user is a removed user- To be deleted", user);
                  results.push(needle.deleteAsync(context.baseUrl + ("/openvpn/server/" + server.instance + "/users/" + user.cname), {
                    json: true
                  }).then(function(resp) {
                    if (resp[0].statusCode !== 200) {
                      throw new Error('invalidStatusCode');
                    }
                    historyusers.pop(user);
                    return resp.body;
                  })["catch"](function(err) {
                    throw err;
                  }));
                } else {
                  results.push(void 0);
                }
              }
              return results;
            }
          }).then(function(resp) {
            return resp;
          })["catch"](function(err) {
            throw err;
          });
        }
        if (clients != null) {
          return Promise.map(clients, function(client) {
            var differences;
            console.log("inside update client map ", client);
            if (client.instance == null) {
              return needle.postAsync(context.baseUrl + "/openvpn/client", client.config, {
                json: true
              }).then(function(resp) {
                if (resp[0].statusCode !== 200) {
                  throw new Error('invalidStatusCode');
                }
                client.instance = resp[1].id;
                if (client.history == null) {
                  client.history = {};
                }
                client.history.config = utils.extend({}, client.config);
                client.history.users = [];
                return client;
              })["catch"](function(err) {
                throw err;
              });
            } else if ((client.instance != null) && (client.config != null) && (client.history.config != null)) {
              differences = diff(client.config, client.history.config);
              if (!(utils.isEmpty(differences) || (differences == null))) {
                return needle.putAsync(context.baseUrl + ("/openvpn/client/" + client.instance), client.config, {
                  json: true
                }).then(function(resp) {
                  if (resp[0].statusCode !== 200) {
                    throw new Error('invalidStatusCode');
                  }
                  client.history.config = client.config;
                  return client;
                })["catch"](function(err) {
                  throw err;
                });
              }
            }
          });
        }
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return resp;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  module.exports.start = Start;

  module.exports.stop = Stop;

  module.exports.update = Update;

}).call(this);
