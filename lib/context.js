// Generated by CoffeeScript 1.9.3
(function() {
  var DeleteClient, DeleteServer, DeleteUser, GetHistoryObject, GetInstanceObject, PostClient, PostServer, PostUser, Promise, PutClient, PutServer, Start, Stop, Update, UpdateUsers, UserExists, Validate, assert, async, diff, getPromise, needle, removeItem, schema, schema_client, schema_server, schema_user, utils, validate;

  validate = require('json-schema').validate;

  assert = require('assert');

  Promise = require('bluebird');

  async = require('async');

  needle = Promise.promisifyAll(require('needle'));

  utils = require('utils')._;

  diff = require('deep-diff').diff;

  schema_user = require('./schema').user;

  schema_server = require('./schema').server;

  schema_client = require('./schema').client;

  schema = {
    "server": schema_server,
    "client": schema_client,
    "user": schema_user
  };

  getPromise = function() {
    return new Promise(function(resolve, reject) {
      return resolve();
    });
  };

  PostServer = function(baseUrl, server) {
    return needle.postAsync(baseUrl + "/openvpn/server", server.config, {
      json: true
    }).then((function(_this) {
      return function(resp) {
        console.log("statuscode: ", resp[0].statusCode);
        if (resp[0].statusCode !== 200) {
          throw new Error('invalidStatusCode');
        }
        return {
          id: server.id,
          instance_id: resp[1].id
        };
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  PostClient = function(baseUrl, client) {
    console.log("post a new client", client.config);
    return needle.postAsync(baseUrl + "/openvpn/client", client.config, {
      json: true
    }).then((function(_this) {
      return function(resp) {
        if (resp[0].statusCode !== 200) {
          throw new Error('invalidStatusCode');
        }
        return {
          id: client.id,
          instance_id: resp[1].id
        };
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  DeleteServer = function(baseUrl, server, instanceid) {
    return needle.deleteAsync(baseUrl + ("/openvpn/server/" + instanceid), {
      json: true
    }).then((function(_this) {
      return function(resp) {
        if (resp[0].statusCode !== 204) {
          throw new Error('invalidStatusCode');
        }
        return server;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  DeleteClient = function(baseUrl, client, instanceid) {
    return needle.deleteAsync(baseUrl + ("/openvpn/client/" + instanceid), {
      json: true
    }).then((function(_this) {
      return function(resp) {
        if (resp[0].statusCode !== 204) {
          throw new Error('invalidStatusCode');
        }
        return client;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  PutServer = function(baseUrl, server, instanceid) {
    return needle.putAsync(baseUrl + ("/openvpn/server/" + instanceid), server.config, {
      json: true
    }).then((function(_this) {
      return function(resp) {
        if (resp[0].statusCode !== 200) {
          throw new Error('invalidStatusCode');
        }
        return server;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  PutClient = function(baseUrl, client, instanceid) {
    return needle.putAsync(baseUrl + ("/openvpn/client/" + instanceid), client.config, {
      json: true
    }).then((function(_this) {
      return function(resp) {
        console.log("respo code", resp[0].statusCode);
        if (resp[0].statusCode !== 200) {
          throw new Error('invalidStatusCode');
        }
        return client;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  PostUser = function(baseUrl, serverid, user) {
    return needle.postAsync(baseUrl + ("/openvpn/server/" + serverid + "/users"), user, {
      json: true
    }).then((function(_this) {
      return function(resp) {
        if (resp[0].statusCode !== 200) {
          throw new Error('invalidStatusCode');
        }
        return resp.body;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  DeleteUser = function(baseUrl, serverid, user) {
    return needle.deleteAsync(baseUrl + ("/openvpn/server/" + serverid + "/users/" + user.cname), {
      json: true
    }).then((function(_this) {
      return function(resp) {
        console.log("response code is", resp[0].statusCode);
        if (resp[0].statusCode !== 200) {
          throw new Error('invalidStatusCode');
        }
        return resp.body;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  GetInstanceObject = function(list, id) {
    var item, j, len;
    for (j = 0, len = list.length; j < len; j++) {
      item = list[j];
      if (item.id === id) {
        return item;
      }
    }
    return null;
  };

  GetHistoryObject = function(history, id) {
    var j, len, obj;
    for (j = 0, len = history.length; j < len; j++) {
      obj = history[j];
      if (obj.id === id) {
        return obj;
      }
    }
    return null;
  };

  removeItem = function(list, id) {
    var index, item, itr, j, len;
    itr = 0;
    for (j = 0, len = list.length; j < len; j++) {
      item = list[j];
      if (item.id === id) {
        index = itr;
        break;
      }
      itr++;
    }
    console.log("iterator is ", itr);
    console.log("index is", index);
    return delete list[index];
  };

  UserExists = function(list, id) {
    var item, j, len;
    for (j = 0, len = list.length; j < len; j++) {
      item = list[j];
      if (item.id === id) {
        return true;
      }
    }
    return false;
  };

  Start = function(context) {
    var clients, config, configObj, ref, ref1, ref2, ref3, ref4, servers;
    if (!(context.bInstalledPackages && context.service.name)) {
      throw new Error('openvpn-storm.Start missingParams');
    }
    configObj = (ref = context.service.factoryConfig) != null ? ref.config : void 0;
    config = configObj[context.service.name];
    servers = (ref1 = config.servers) != null ? ref1 : [];
    clients = (ref2 = config.clients) != null ? ref2 : [];
    if (context.instances == null) {
      context.instances = [];
    }
    if (context.history == null) {
      context.history = {};
    }
    if ((ref3 = context.history) != null) {
      ref3.servers = [];
    }
    if ((ref4 = context.history) != null) {
      ref4.clients = [];
    }
    if (utils.isEmpty(servers) && utils.isEmpty(clients)) {
      throw new Error("openvpn-storm.Start missing server,client info");
    }
    if (config.enable !== true) {
      return context;
    }
    return getPromise().then((function(_this) {
      return function(resp) {
        return Promise.map(servers, function(server) {
          return PostServer(context.baseUrl, server);
        }).then(function(resp) {
          var item, j, len;
          for (j = 0, len = resp.length; j < len; j++) {
            item = resp[j];
            context.instances.push(item);
          }
          return resp;
        }).then(function(resp) {
          var i, j, k, len, len1, server;
          console.log("resp", resp);
          console.log("Servers", servers);
          if (utils.isEmpty(servers)) {
            return resp;
          }
          for (j = 0, len = resp.length; j < len; j++) {
            i = resp[j];
            for (k = 0, len1 = servers.length; k < len1; k++) {
              server = servers[k];
              if (server.id === i.id) {
                context.history.servers.push(server);
              }
            }
          }
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return Promise.map(clients, function(client) {
          return PostClient(context.baseUrl, client);
        }).then(function(resp) {
          var item, j, len;
          for (j = 0, len = resp.length; j < len; j++) {
            item = resp[j];
            context.instances.push(item);
          }
          return resp;
        }).then(function(resp) {
          var client, i, j, k, len, len1;
          if (utils.isEmpty(clients)) {
            return;
          }
          for (j = 0, len = resp.length; j < len; j++) {
            i = resp[j];
            for (k = 0, len1 = clients.length; k < len1; k++) {
              client = clients[k];
              if (client.id === i.id) {
                context.history.clients.push(client);
              }
            }
          }
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return context;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  Stop = function(context) {
    var clients, config, history, instances, ref, ref1, servers;
    if (!(context.bInstalledPackages && context.service.name)) {
      throw new Error('openvpn-storm.Stop missingParams');
    }
    config = context.policyConfig[context.service.name];
    servers = (ref = config.servers) != null ? ref : [];
    clients = (ref1 = config.clients) != null ? ref1 : [];
    instances = context.instances;
    history = context.history;
    if (utils.isEmpty(servers) && utils.isEmpty(clients)) {
      throw new Error("openvpn-storm.Stop missing server,client info");
    }
    if (config.enable !== true) {
      return context;
    }
    return getPromise().then((function(_this) {
      return function(resp) {
        return Promise.map(servers, function(server) {
          var instance;
          instance = GetInstanceObject(instances, server.id);
          console.log("instance is ");
          console.log(instance);
          if (instance == null) {
            throw new Error(" server instance is not found");
          }
          return DeleteServer(context.baseUrl, server, instance.instance_id);
        }).then(function(resp) {
          var j, len, s;
          for (j = 0, len = resp.length; j < len; j++) {
            s = resp[j];
            removeItem(instances, s.id);
            removeItem(history.servers, s.id);
          }
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return Promise.map(clients, function(client) {
          var instance;
          instance = GetInstanceObject(instances, client.id);
          console.log("instance is ");
          console.log(instance);
          if (instance == null) {
            throw new Error(" client instance is not found");
          }
          return DeleteClient(context.baseUrl, client, instance.instance_id);
        }).then(function(resp) {
          var c, j, len;
          for (j = 0, len = resp.length; j < len; j++) {
            c = resp[j];
            removeItem(instances, c.id);
            removeItem(history.clients, c.id);
          }
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return context;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };


  /*
  #Update logic
      iterate the clients array
         a. if instance is not present - assume that is the new client . 
             - post the client and update the instance id, and save the config in the history
         b. if the instance is present (assume this is the existing running client)
              i) diff with config and history config 
                  if diff is found, then client config is changed,
                  put the client config 
      
      iterate the servers array. 
         a. if instance is not preset  - assume this is  a new server.  
             - post the server and update the instance id, and save the config in history
         b.if instance is present, (assume this is the existing running server) 
              i) diff with config and history config 
                  if diff is found, then server config is changed,
                  put the server config 
  
         c. check the current users aray and history users array in the server         
               if current user is not present in the history users 
                        then this is the new user , POST the new user and update it in the history users
              if history user is not present in the current users , 
                         then this uses to be deleted. DELETE this user
      
  
  
  
  UpdateClient = (baseUrl,client)->
      getPromise()
      .then (resp) =>
          return PostClient(baseUrl,client) unless client.instance?
          differences = diff(client.config,client.history.config)
          return PutClient(baseUrl,client) unless utils.isEmpty(differences) or  not differences?
          return client #no difference in client config
      .catch (err) =>
          throw err
  
  
  UpdateServer = (baseUrl,server)->
      getPromise()
      .then (resp) =>
          #put server , post server
          return  PostServer(baseUrl,server) unless server.instance?
          differences = diff(server.config,server.history.config)
          return  PutServer(baseUrl,server) unless utils.isEmpty(differences) or  not differences?
          #return resolve server #no difference in server config
          
      .then (resp) =>
  
          currentusers = server.users ? []
          historyusers = server.history.users ? []
  
          #process the currentusers array
          console.log "currentusers ",currentusers
          Promise.map currentusers, (currentuser) =>
              console.log "currentuser  ",currentuser
              result =  UserExists(historyusers, currentuser.id)
              if result is false
                  historyusers.push currentuser
                  return PostUser(baseUrl,server.instance,currentuser)
          .then (resp) =>
              return resp
          .catch (err) =>
              throw err
      .then (resp)=>
          currentusers = server.users ? []
          historyusers = server.history.users ? []
          #process the historyusers array
          console.log "historyusers ", historyusers
          Promise.map historyusers, (historyuser) =>
              console.log "historyuser ", historyuser
              result =  UserExists(currentusers, historyuser.id)
              if result is false
                  historyusers.pop historyuser
                  return DeleteUser(baseUrl,server.instance,historyuser)
          .then (resp) =>
              return resp
          .catch (err) =>
              throw err
      .then (resp)=>
          return resp
      .catch (err)=>
          throw err
   */

  UpdateUsers = function(baseUrl, instanceid, server, history) {
    return getPromise().then((function(_this) {
      return function(resp) {
        var currentusers, historyusers, ref, ref1;
        currentusers = (ref = server.users) != null ? ref : [];
        historyusers = (ref1 = history.users) != null ? ref1 : [];
        console.log("currentusers ", currentusers);
        return Promise.map(currentusers, function(currentuser) {
          var result;
          result = UserExists(historyusers, currentuser.id);
          if (result === false) {
            historyusers.push(currentuser);
            console.log("Posting the user ", currentuser);
            return PostUser(baseUrl, instanceid, currentuser);
          }
        }).then(function(resp) {
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(resp) {
        var currentusers, historyusers, ref, ref1;
        currentusers = (ref = server.users) != null ? ref : [];
        historyusers = (ref1 = history.users) != null ? ref1 : [];
        console.log("historyusers ", historyusers);
        return Promise.map(historyusers, function(historyuser) {
          var result;
          result = UserExists(currentusers, historyuser.id);
          if (result === false) {
            historyusers.pop(historyuser);
            console.log("Deleting the user ", historyuser);
            return DeleteUser(baseUrl, instanceid, historyuser);
          }
        }).then(function(resp) {
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return resp;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  Update = function(context) {
    var clients, config, history, instances, ref, ref1, servers;
    if (!(context.bInstalledPackages && context.service.name)) {
      throw new Error('openvpn-storm.Update missingParams');
    }
    config = context.policyConfig[context.service.name];
    servers = (ref = config.servers) != null ? ref : [];
    clients = (ref1 = config.clients) != null ? ref1 : [];
    instances = context.instances;
    history = context.history;
    return getPromise().then((function(_this) {
      return function(resp) {
        return Promise.map(clients, function(client) {
          var instance;
          console.log("client is ", client);
          instance = GetInstanceObject(instances, client.id);
          console.log("instance is ", instance);
          if (instance === null) {
            return getPromise().then(function(resp) {
              console.log("posting a new client");
              return PostClient(context.baseUrl, client);
            }).then(function(resp) {
              console.log("Update Post client Response");
              console.log(resp);
              context.instances.push(resp);
              return resp;
            }).then(function(resp) {
              context.history.clients.push(client);
              return resp;
            })["catch"](function(err) {
              throw err;
            });
          } else {
            history = GetHistoryObject(context.history.clients, client.id);
            console.log("history is ");
            console.log(history);
            return getPromise().then(function(resp) {
              return PutClient(context.baseUrl, client, instance.instance_id);
            }).then(function(resp) {
              history = utils.extend({}, client.config);
              return resp;
            })["catch"](function(err) {
              throw err;
            });
          }
        }).then(function(resp) {
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return Promise.map(servers, function(server) {
          var instance;
          instance = GetInstanceObject(instances, server.id);
          console.log("instance is ");
          console.log(instance);
          if (instance === null) {
            return getPromise().then(function(resp) {
              return PostServer(context.baseUrl, server);
            }).then(function(resp) {
              console.log("Update Post Server Response");
              context.instances.push(resp);
              Promise.map(server.users, function(user) {
                return PostUser(context.baseUrl, resp.instance_id, user);
              }).then(function(resp) {
                return resp;
              })["catch"](function(err) {
                return err;
              });
              return resp;
            }).then(function(resp) {
              context.history.servers.push(server);
              return resp;
            })["catch"](function(err) {
              throw err;
            });
          } else {
            history = GetHistoryObject(context.history.servers, server.id);
            console.log("history is ");
            console.log(history);
            return getPromise().then(function(resp) {
              return PutServer(context.baseUrl, server, instance.instance_id);
            }).then(function(resp) {
              return UpdateUsers(context.baseUrl, instance.instance_id, server, history);
            }).then(function(resp) {
              history.config = utils.extend({}, server.config);
              return resp;
            })["catch"](function(err) {
              throw err;
            });
          }
        }).then(function(resp) {
          return resp;
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(response) {
        return context;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  Validate = function(config) {
    var chk, client, j, k, l, len, len1, len2, ref, ref1, ref2, server, user;
    if (!((config.servers != null) && (config.clients != null))) {
      throw new Error("openvpn.Validate - invalid input");
    }
    ref = config.servers;
    for (j = 0, len = ref.length; j < len; j++) {
      server = ref[j];
      chk = validate(server.config, schema['server']);
      console.log('server validate result ', chk);
      if (!chk.valid) {
        throw new Error("server schema check failed" + chk.valid);
        return false;
      }
      if (server.users != null) {
        ref1 = server.users;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          user = ref1[k];
          chk = validate(user, schema['user']);
          console.log('user validate result ', chk);
          if (!chk.valid) {
            throw new Error("user schema check failed" + chk.valid);
            return false;
          }
        }
      }
    }
    ref2 = config.clients;
    for (l = 0, len2 = ref2.length; l < len2; l++) {
      client = ref2[l];
      chk = validate(client.config, schema['client']);
      console.log('client validate result ', chk);
      if (!chk.valid) {
        throw new Error("client schema check failed" + chk.valid);
        return false;
      }
    }
    return true;
  };

  module.exports.start = Start;

  module.exports.stop = Stop;

  module.exports.update = Update;

  module.exports.validate = Validate;

}).call(this);
